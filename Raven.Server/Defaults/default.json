[
  {
    "DocId": "raven_documentation/index",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Documentation Index </h2><p><br /></p><h4>Basic Document Operations</h4><p><a href=\"/raven/view.html?docId=raven_documentation/docs_http_api_create\" rel=\"nofollow\">Create</a></p><p><br /></p><p><a href=\"/raven/view.html?docId=raven_documentation/docs_http_api_get\" rel=\"nofollow\">Read</a><br /></p><p><br /></p><p><a href=\"/raven/view.html?docId=raven_documentation/docs_http_api_update\" rel=\"nofollow\">Update</a><br /></p><p><br /></p><p><a href=\"/raven/view.html?docId=raven_documentation/docs_http_api_delete\" rel=\"nofollow\">Delete</a><br /></p><p><br /></p><p></p><h4>Indexes and Map / Reduce</h4><p></p><p><a href=\"/raven/view.html?docId=raven_documentation/docs_http_indexes\" rel=\"nofollow\">Indexes</a></p><p><br /></p><h4>Additional Topics</h4><div><a href=\"/raven/view.html?docId=raven_documentation/docs_http_api_restful\" rel=\"nofollow\">Is this Api RESTful?</a><br /></div><div><br /></div><div><a href=\"/raven/view.html?docId=raven_documentation/docs_http_api_concurrency\" rel=\"nofollow\">Handling Concurrency with E-Tags</a><br /></div><p></p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Index"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_api_create",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Creating a Document</h2><p>\nUse the Create API to insert a JSON document into RavenDB. There are two ways to use the Create API.</p><p><br /></p><p></p><h4>Specifying the Id</h4><p>To create the JSON document for Bob's address with an id value of \"bobs_address\":\n</p><pre>&gt; curl -X PUT http://localhost:8080/docs/bobs_address -d \"{ FirstName: 'Bob', LastName: 'Smith', Address: '5 Elm St' }\"\n</pre>\nThe RavenDB HTTP server will respond with the id of the document you just created:\n<pre>HTTP/1.1 201 Created\n\n{\n  \"id\" : \"bobs_address\"\n}\n</pre><h4><br /></h4><h4>Let RavenBD Create the Id</h4><p>\nTo create the JSON document for Bob's address and let RavenDB generate a unique id:\n</p><p></p><pre>&gt; curl -X POST http://localhost:8080/docs -d \"{ FirstName: 'Bob', LastName: 'Smith', Address: '5 Elm St' }\"\n</pre>\nThe RavenDB HTTP server will respond with the id it generates for the document you just created:\n<pre>HTTP/1.1 201 Created\n\n{\n  \"id\" : \"458620e0-2a65-11df-9a26-001c251ced36\"\n}</pre><p><br /></p><p></p><h4>Put vs. Post</h4><p></p><p>\nThe difference between you specifying the id and RavenDB specifying the id is the difference between the HTTP verbs PUT and POST.</p><p><br /></p><p>\nIn HTTP, a PUT request is considered to be idempotent, meaning you can run the same PUT request over and over again with the same result.</p><p><br /></p><p>Namely, a PUT in RavenDB will always create the specified document at the request URL, if necessary overwriting what was there before.</p><p><br /></p><p>In contrast, a POST request is understood to not always produce the same result when it is run multiple times.</p><p><br /></p><p>So for RavenDB, a repeated POST request for the same document will create that document in a new place, with a new id each time.</p><p><br /></p><p><br /></p><h4>Invalid Put's and Post's</h4><p></p><p></p><p>A PUT request to /docs without specifying an id or a POST to a document URL are both considered invalid requests and RavenDB will return aÂ HTTP/1.1 404 Not Found.</p><p></p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Creating a Document"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_api_get",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Reading a Document</h2><p>\nUse the Read API to get a JSON document from RavenDB based on its id. For example, to get the JSON document for Bob's address, with an id value of \"bobs_address\":\n</p><pre>&gt; curl -X GET http://localhost:8080/docs/bobs_address\n</pre>\nThe RavenDB HTTP server will respond with:\n<pre>HTTP/1.1 200 OK\n\n{\n  \"FirstName\": \"Bob\",\n  \"LastName\": \"Smith\",\n  \"Address\": \"5 Elm St.\"\n}\n</pre><h4><br /></h4><h4>Urls and GET in Http</h4><p>\nIf you're reading this on a web page, chances are you familiar with URLs or Uniform Resource Locators.\n</p><p><br /></p><p>\nIn HTTP, URLs uniquely identify resources such as web pages (http://www.google.com/index.html).\n</p><p><br /></p><p>\nURLs aren't limited to pointing at just web pages; in RavenDB, every JSON document that RavenDB stores is reachable over HTTP by a URL.\n</p><p><br /></p><p>\nThis URL is composed of the RavenDB server name, the \"docs\" collection name and the id of the document.\n</p><p><br /></p><p>\nSo in the previous example, the URL of the document for Bob's address was http://locahost:8080 (the RavenDB server) + \"/docs\" + \"bobs_address\" (the document id).\n</p><h4><br /></h4><h4>Reading Something That's Not There</h4><p>\nRavenDB follows HTTP conventions and responds with a \"HTTP/1.1 404 Not Found\" if the URL specified points a JSON document that does not exist in RavenDB.\n</p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Reading a Document"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_api_update",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Updating a Document</h2><p>\nUse the Update API to change part or all of a JSON document that is already in RavenDB. There are two ways to use the Update API.</p><p><br /></p><p></p><h4>Update By Overwrite</h4><p>The most straight forward way to update a JSON document is to overwrite it with a new one.</p><p><br /></p><p>Bob's address is already in RavenDB, with an id of \"bobs_address.\":</p><pre>{\n  \"FirstName\": \"Bob\",\n  \"LastName\": \"Smith\",\n  \"Address\": \"5 Elm St.\"\n}\n</pre><p>To update Bob's address when he moves one street over:</p><pre>&gt; curl -X PUT http://localhost:8080/docs/bobs_address -d \"{ FirstName: 'Bob', LastName: 'Smith', Address: '10 Oak Ave' }\"\n</pre>\nThe RavenDB HTTP server will respond with the id of the document you just updated:\n<pre>HTTP/1.1 201 Created\n\n{\n  \"id\" : \"bobs_address\"\n}\n</pre><p>A subsequent get of this document confirms that the address reflects the latest value:</p><pre>{\n  \"FirstName\": \"Bob\",\n  \"LastName\": \"Smith\",\n  \"Address\": \"10 Oak St.\"\n}\n</pre><p><br /></p><p></p><h4>Patching</h4><p>Another way to update an existing document in RavenDB is to specify just the fields of a document to update or remove:</p><p><br /></p><p><i>---documentation forthcoming</i></p><p><br /></p><p></p><h4>Tracking Updates with E-Tags</h4><p>Both the update by overwrite and patch methods of updating a document cause RavenDB to update the entity tag (e-tag) for that document.</p><p><br /></p><p>E-tags are used in HTTP to determine if a cached version of the requested resource (document) is identical to the current version of that document on the server.</p><p><br /></p><p>The e-tag for a document is returned in the headers of the server response to a GET request from the client.</p><p><br /></p><p>So in our example above, the full RavenDB response to a get of the first version of bobs_address would be:</p><pre>&lt; HTTP/1.1 200 OK\n&lt; Content-Length: 76\n&lt; Content-Type: application/x-www-form-urlencoded\n&lt; ETag: b8ec9a84-2a62-11df-9a26-001c251ced36\n&lt; Server: Microsoft-HTTPAPI/2.0\n&lt; Date: Mon, 08 Mar 2010 04:32:33 GMT\n&lt;\n{\n  \"FirstName\": \"Bob\",\n  \"LastName\": \"Smith\",\n  \"Address\": \"5 Elm St\"\n}\n</pre><p><br /></p><p>Continuing with the example, the full RavenDB response to a get of the updated version of bobs_address would be:</p><pre>&lt; HTTP/1.1 200 OK\n&lt; Content-Length: 77\n&lt; Content-Type: application/x-www-form-urlencoded\n&lt; ETag: 077597f1-2a6c-11df-9a26-001c251ced36\n&lt; Server: Microsoft-HTTPAPI/2.0\n&lt; Date: Mon, 08 Mar 2010 04:35:38 GMT\n&lt;\n{\n  \"FirstName\": \"Bob\",\n  \"LastName\": \"Smith\",\n  \"Address\": \"10 Oak St\"\n}\n</pre><p><br /></p><p>As you can see the e-tag has changed with the document update, allowing you to see that this document has been updated.</p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Updating a Document"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_api_delete",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Deleting a Document</h2><p>\nUse the Delete API to remove a JSON document from RavenDB based on its id. For example, to remove the JSON document for Bob's address, with an id value of \"bobs_address\":\n</p><pre>&gt; curl -X DELETE http://localhost:8080/docs/bobs_address\n</pre><p>\nFor a successful delete, RavenDB will respond with an HTTP response code of \"HTTP/1.1 204 No Content\".\n</p><p><br /></p>\nAs with the Read API, you specify the URL of the document to delete. The difference is the HTTP verb you use, DELETE for deletes, GET for reads.<p></p><p><br /></p><h4>Hard vs. Soft Deletes</h4><p>\nDeleting a document through the HTTP API is not reversible. In database terms it is termed a \"hard\" delete.\n</p><p><br /></p><p>\nAn alternative approach is to mark a document with a deleted flag and then ignore documents like this in your business logic.\n</p><p><br /></p><p>\nThis approach, a \"soft\" delete, preserves the data intact in RavenDB and can be useful for auditing or undoing a user's actions.\n</p><p><br /></p><p>\nThe right approach for you will depend on the problem space your data is modeling.\n</p><p><br /></p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Deleting a Document"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_security",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Security - Anonymous Users</h2><p>\nIn RavenDB, you can control the privileges of unauthenticated or anonymous users. By default such anonymous uses can retrieve any documents they want (or to put it in terms of the Http Api, they can GET any document.) The other options are to grant anonymous users total control of the database (\"All\") or no access at all (\"None\"). These values are listed in the AnonymousUserAccessMode enumerator in the RavenDB source code. You can set which option you prefer in the app.config as follows:\n</p><pre>  &lt;appSettings&gt;\n    &lt;add key=\"AnonymousAccess\" value=\"All\"/&gt;\n  &lt;/appSettings&gt;</pre><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Security - Anonymous Users"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_indexes",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Indexes &amp; Map / Reduce</h2><p>\nUse the Index API to enable advanced fast and complex queries of JSON documents already in RavenDB. Indexes are expressed using LINQ and are composed of two parts, a map and a reduce function.</p><p>* To follow along with these examples in a demo environment, you may want to enable full access to anonymous users as described here: <a href=\"/raven/view.html?docId=raven_documentation/docs_security\" rel=\"nofollow\">Security</a>.</p><p></p><h4>Creating an Index - Map Only</h4><div>The simplest type of Index in RavenDB only has a map function. This type of index functions much like an index in a relational database. It offers fast access to documents in RavenDB by a property or properties other then their unique id. For example, imagine we had a document for user in our address book and wanted to find any users who live in Maryland. We have five users, so five documents:</div><div><br /></div><div><pre>http://localhost:8080/docs/bob\n{\n   \"Name\": \"Bob\",\n   \"HomeState\": \"Maryland\",\n   \"ObjectType\": \"User\"\n}\n\nhttp://localhost:8080/docs/sarah\n{\n   \"Name\": \"Sarah\",\n   \"HomeState\": \"Illinois\",\n   \"ObjectType\": \"User\"\n}\n\nhttp://localhost:8080/docs/paul\n{\n   \"Name\": \"Paul\",\n   \"HomeState\": \"Maryland\",\n   \"ObjectType\": \"User\"\n}\n\nhttp://localhost:8080/docs/mary\n{\n   \"Name\": \"Mary\",\n   \"HomeState\": \"Maryland\",\n   \"ObjectType\": \"User\"\n}\n\nhttp://localhost:8080/docs/george\n{\n   \"Name\": \"Bob\",\n   \"HomeState\": \"California\",\n   \"ObjectType\": \"User\"\n}\n\nIf you're following along with curl:\n&gt; curl -X PUT http://localhost:8080/docs/bob -d \"{ Name: 'Bob', HomeState: 'Maryland', ObjectType: 'User' }\"\n&gt; curl -X PUT http://localhost:8080/docs/sarah -d \"{ Name: 'Sarah', HomeState: 'Illinois', ObjectType: 'User' }\"\n&gt; curl -X PUT http://localhost:8080/docs/paul -d \"{ Name: 'Paul', HomeState: 'Maryland', ObjectType: 'User' }\"\n&gt; curl -X PUT http://localhost:8080/docs/mary -d \"{ Name: 'Mary', HomeState: 'Maryland', ObjectType: 'User' }\"\n&gt; curl -X PUT http://localhost:8080/docs/george -d \"{ Name: 'George', HomeState: 'California', ObjectType: 'User' }\"\n</pre></div><div><br /></div><div>To create an index to retrieve these documents by HomeState, the HTTP Index API can be used as follows:</div><div><br /></div><div><pre>&gt; curl -X PUT http://localhost:8080/indexes/usersByHomeState -d \"{ Map:'from doc in docs\\r\\nwhere doc.ObjectType==\\\"User\\\"\\r\\nselect new { doc.HomeState }' }\"\n</pre></div><p>\nRavenDB will respond with a 201 Created, and confirm the name of the index just created:</p><pre>HTTP/1.1 201 Created\n{\"index\":\"usersByHomeState\"}</pre><h4>Querying by Index</h4><p></p><p>Once you have created an index you can query for documents by using the Index Query API:</p><pre>&gt; curl -X GET http://localhost:8080/indexes/usersByHomeState?query=HomeState%3AMaryland\n</pre><p>\nRavenDB will respond with a result set that includes all the matching records, plus some other useful information:\n</p><pre>{\"Results\":\n[{\"Name\":\"Mary\",\"HomeState\":\"Maryland\",\"ObjectType\":\"User\",\"@metadata\":{\"Content-Type\":\"application/x-www-form-urlencoded\",\"@id\":\"mary\",\"@etag\":\"25ff8144-36f8-11df-858f-001de034b773\"}},\n{\"Name\":\"Paul\",\"HomeState\":\"Maryland\",\"ObjectType\":\"User\",\"@metadata\":{\"Content-Type\":\"application/x-www-form-urlencoded\",\"@id\":\"paul\",\"@etag\":\"25ff8145-36f8-11df-858f-001de034b773\"}},\n{\"Name\":\"Bob\",\"HomeState\":\"Maryland\",\"ObjectType\":\"User\",\"@metadata\":{\"Content-Type\":\"application/x-www-form-urlencoded\",\"@id\":\"bob\",\"@etag\":\"25ff8147-36f8-11df-858f-001de034b773\"}}],\n\"IsStale\":false,\"TotalResults\":3}\n</pre><p>In the result set, \"TotalResults\" is a count of the matching records. \"IsStale\" is a boolean indicator of whether or not this index is actively being updated by a background process. When an index is first created or when new documents are added that could be part of the index, RavenDB runs a background process to update the index. If this process is running while an index query is issued, then the last known results will be returned, but clearly marked as stale with \"IsStale\" set to true.\n</p><h4>Paging Results</h4><p>RavenDB allows you to control how many documents are returned from an index query by using the query string arguments \"start\" and \"pageSize\". \"pageSize\" specifies how many records to return, \"start\" is the starting position within all results to return \"pageSize\" records from. So with our Maryland users, we could break up the results as follows:</p><pre>&gt; curl -X GET \"http://localhost:8080/indexes/usersByHomeState?query=HomeState%3AMaryland&amp;start=0&amp;pageSize=2\"\n*the quotes around the url here are to avoid the Windows command prompt from trying to parse out \"start\" and \"pageSize\" as additional commands*\n\n{\"Results\":\n[{\"Name\":\"Mary\",\"HomeState\":\"Maryland\",\"ObjectType\":\"User\",\"@metadata\":{\"Content-Type\":\"application/x-www-form-urlencoded\",\"@id\":\"mary\",\"@etag\":\"25ff8144-36f8-11df-858f-001de034b773\"}},\n{\"Name\":\"Paul\",\"HomeState\":\"Maryland\",\"ObjectType\":\"User\",\"@metadata\":{\"Content-Type\":\"application/x-www-form-urlencoded\",\"@id\":\"paul\",\"@etag\":\"25ff8145-36f8-11df-858f-001de034b773\"}}],\n\"IsStale\":false,\"TotalResults\":3}\n\n&gt; curl -X GET \"http://localhost:8080/indexes/usersByHomeState?query=HomeState%3AMaryland&amp;start=2&amp;pageSize=2\"\n\n{\"Results\":\n[{\"Name\":\"Bob\",\"HomeState\":\"Maryland\",\"ObjectType\":\"User\",\"@metadata\":{\"Content-Type\":\"application/x-www-form-urlencoded\",\"@id\":\"bob\",\"@etag\":\"25ff8147-36f8-11df-858f-001de034b773\"}}],\n\"IsStale\":false,\"TotalResults\":3}\n</pre><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Indexes & Map / Reduce"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_api_restful",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Is the RavenDB Http Api RESTful?</h2><p><br /></p><p>Providing the HTTP API as a first class component underscores the importance we place on having a platform agnostic, web friendly way to work with RavenDB.Â </p><p><br /></p><p>A generally accepted part of being web friendly is to follow the REST architectural style, to be \"RESTful.\"Â </p><p><br /></p><p>RESTful web APIs are used to manipulate resources, in this case, the documents being stored in RavenDB.\nTo be RESTful, these resources must be addressable by a URI, identifiable by a MIME type, and support operations using the HTTP verbs or methods of GET, POST, PUT and DELETE.Â </p><p><br /></p><p>As you'll see in this documentation, RavenDB's web API meets these criteria, but as there is no official standard for what exactly the various HTTP methods should do, there is some disagreement over what pure REST is and is not.</p><p><br /></p><p>In addition, while being RESTful is a goal for the HTTP API, it is secondary to the goal of exposing easy to use and powerful functionality over RavenDB such as supporting batching, or multi document transactions.</p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Is the RavenDB Http Api RESTful?"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  },
  {
    "DocId": "raven_documentation/docs_http_api_concurrency",
    "Document": {
      "Html": "<div class=\"layoutregion\"><div id=\"g_body\" style=\"overflow: auto;\"><h2>Http Api - Optimistic Concurrency and E-Tags</h2><p>RavenDB defines some simple rules to determine how to handle concurrent or near requests from the HTTP API against the same document.</p><p><br /></p><h4>Leveraging E-Tags</h4><p>Every document in RavenDB has a corresponding e-tag (entity tag). This e-tag is updated by RavenDB every time the document is changed.</p><p><br /></p><p>When you request to update a document, you can specify the e-tag of the document you were working with in the \"If-Match\" element of the header:</p><p><br /></p><pre>&gt; curl --header \"If-Match:dd62a2e0-2744-11df-a9ff-001c251ced36\"Â \n         -X PUT http://localhost:8080/docs/bobs_address -d \"{ FirstName : 'Bob', LastName: 'Smith', Address: '5 Elm St.' }\"\n</pre><p><br /></p><p>If the e-tag specified in the header matches the current e-tag of the document in RavenDB, then this update will go through successfully.</p><p><br /></p><p>If the document has been updated by someone else before you, then the e-tag's won't match and RavenDB will return a conflict error:</p><pre>&lt; HTTP/1.1 409 Conflict\n\n{\"url\":\"/docs/bobs_address\",\"actualETag\":\"dd62a2e0-2744-11df-a9ff-001c251ced36\",\"expectedETag\":\"ac6ca153-2745-11df-a9ff-001c251ced36\",\n         \"error\":\"PUT attempted on document 'bobs_address' using a non current etag\"}\n</pre><p>\nAt this point, the update was reject, nothing on the server has changed, and it is up to you as the user of the API to determine how to respond to this conflict.\n</p><h4><br /></h4><h4>Last One in Wins</h4><p>When the e-tag is not specified in the header for a given request, the last request processed for that URL wins.</p><p><br /></p><p>Because of this, to ensure that updates are processed as you expect them to, it is recommended you always specify an e-tag for update requests.</p><p><br /></p><p>Unless your problem space demands it, it is generally not useful to specify an e-tag for deletes.</p><wbr></wbr></div><div class=\"clear\"></div></div>",
      "Name": "Http Api - Optimistic Concurrency and E-Tags"
    },
    "Metadata": {
      "Raven-View-Template": "/raven/JSONTemplates/documentation.html"
    }
  }
]